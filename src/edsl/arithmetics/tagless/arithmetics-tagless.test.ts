import { Arithmetics, getInstanceFor } from "./arithmetics-tagless";
import { Kind, URIS } from "fp-ts/HKT";

const InterpreterNumURI = "InterpreterNum";
type InterpreterNumURI = typeof InterpreterNumURI;

const InterpreterStrURI = "InterpreterStr";
type InterpreterStrURI = typeof InterpreterStrURI;

const InterpreterNumThunkURI = "InterpreterNumThunk";
type InterpreterNumThunkURI = typeof InterpreterNumThunkURI;

declare module "fp-ts/lib/HKT" {
  interface URItoKind<A> {
    [InterpreterNumURI]: A;
    [InterpreterStrURI]: A;
    [InterpreterNumThunkURI]: () => A;
  }
}

// todo: type should contain InterpreterNumURI and not string!
const interpreterNum: Arithmetics<InterpreterNumURI, number> = {
  cnst: (a) => Number(a),
  neg: (a) => -a,
  add: (op0, op1) => op0 + op1,
  mul: (op0, op1) => op0 * op1,
};

const interpreterStr: Arithmetics<InterpreterStrURI, string> = {
  cnst: (a) => String(a),
  neg: (a) => "-" + a,
  add: (op0, op1) => "(" + op0 + "+" + op1 + ")",
  mul: (op0, op1) => "(" + op0 + "*" + op1 + ")",
};

const interpreterNumThunk: Arithmetics<InterpreterNumThunkURI, number> = {
  cnst: (a) => () => Number(a),
  neg: (a) => () => -a(),
  add: (op0, op1) => () => op0() + op1(),
  mul: (op0, op1) => () => op0() * op1(),
};

const testSequence =
  <F extends URIS, A>(P: Arithmetics<F, A>) =>
  (a: A, b: A): Kind<F, A> => {
    const p = getInstanceFor(P);
    return p.add(
      p.mul(p.neg(p.cnst(a)), p.cnst(a)),
      p.mul(p.cnst(b), p.cnst(b))
    );
  };

// todo: write this as an unfolder for `ana`
const genAddMullTree = <F extends URIS, A>(
  P: Arithmetics<F, A>
): ((n: number, m: number) => Kind<F, A>) => {
  const p = getInstanceFor(P);
  const it = (n: number, m: number): Kind<F, A> => {
    if (n <= m) return p.cnst(n);

    for (let d = m; d > 1; d--) {
      if (n % d === 0) {
        return p.mul(p.cnst(d), it(n / d, m));
      }
    }

    let a = Math.floor(n / 2);
    let b = n - a;
    return p.add(it(a, m), it(b, m));
  };

  return it;
};

// todo: write this as an unfolder for `ana`
const genAddOneTree = <F extends URIS, A>(
  P: Arithmetics<F, A>
): ((n: number) => Kind<F, A>) => {
  const p = getInstanceFor(P);
  return (n) => {
    let op = p.cnst(1);
    for (let m = n - 1; m > 0; m--) {
      op = p.add(p.cnst(1), op);
    }
    return op;
  };
};

// todo: write transformations between tagged and tagless arithmetics

describe("tagless arithmetics", () => {
  it("evaluates op sequence using `interpreterNum`", () => {
    expect(testSequence(interpreterNum)(1, 2)).toBe(3);
  });

  it("evaluates op sequence using `interpreterStr`", () => {
    expect(testSequence(interpreterStr)(String(1), String(2))).toBe(
      "((-1*1)+(2*2))"
    );
  });

  it("evaluates op sequence using `interpretNumThunk`", () => {
    const res = testSequence(interpreterNumThunk)(1, 2);
    expect(typeof res).toBe("function");
    expect(res()).toBe(3);
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterNum`", () => {
    for (let n = 1; n <= 100; n++)
      expect(genAddMullTree(interpreterNum)(1, 9)).toBe(1);
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterStr`", () => {
    expect(genAddMullTree(interpreterStr)(37, 9)).toBe("((9*2)+(9+(5*2)))");
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterNumThunk`", () => {
    for (let n = 1; n <= 100; n++)
      expect(genAddMullTree(interpreterNumThunk)(n, 9)()).toBe(n);
  });

  it.skip("stack safe versions", () => {
    const n = 2 ** 16;

    expect(() => {
      expect(genAddOneTree(interpreterNum)(n)).toBe(n);
    }).not.toThrow();

    expect(() => {
      genAddOneTree(interpreterStr)(n);
    }).not.toThrow();

    expect(() => {
      genAddOneTree(interpreterNumThunk)(n)();
    }).toThrow();

    expect(() => {
      throw new Error("stack-safe interpreterNumThunk not implemented");
    }).not.toThrow();
  });
});
