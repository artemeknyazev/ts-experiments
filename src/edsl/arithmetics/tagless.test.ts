import {
  Arithmetics,
  getInstanceFor,
  interpreterNum,
  interpreterStr,
  interpreterNumThunk,
  interpreterNumEval,
  interpreterStrEval,
} from "./tagless";

const testSequence =
  <A>(P: Arithmetics<A>) =>
  (a: any, b: any): A => {
    const p = getInstanceFor(P);
    return p.add(
      p.mul(p.neg(p.cnst(a)), p.cnst(a)),
      p.mul(p.cnst(b), p.cnst(b))
    );
  };

// todo: write this as an unfolder for `ana`
const genAddMullTree = <A>(
  P: Arithmetics<A>
): ((n: number, m: number) => A) => {
  const p = getInstanceFor(P);
  const it = (n: number, m: number): A => {
    if (n <= m) return p.cnst(n);

    for (let d = m; d > 1; d--) {
      if (n % d === 0) {
        return p.mul(p.cnst(d), it(n / d, m));
      }
    }

    let a = Math.floor(n / 2);
    let b = n - a;
    return p.add(it(a, m), it(b, m));
  };

  return it;
};

// todo: write this as an unfolder for `ana`
const genAddOneTree = <A>(P: Arithmetics<A>): ((n: number) => A) => {
  const p = getInstanceFor(P);
  return (n) => {
    let op = p.cnst(1);
    for (let m = n - 1; m > 0; m--) {
      op = p.add(p.cnst(1), op);
    }
    return op;
  };
};

// todo: write transformations between tagged and tagless arithmetics

describe("tagless arithmetics", () => {
  it("evaluates op sequence using `interpreterNum`", () => {
    expect(testSequence(interpreterNum)(1, 2)).toBe(3);
  });

  it("evaluates op sequence using `interpreterStr`", () => {
    expect(testSequence(interpreterStr)(String(1), String(2))).toBe(
      "((-1*1)+(2*2))"
    );
  });

  it("evaluates op sequence using `interpretNumThunk`", () => {
    const res = testSequence(interpreterNumThunk)(1, 2);
    expect(typeof res).toBe("function");
    expect(res()).toBe(3);
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterNum`", () => {
    for (let n = 1; n <= 100; n++)
      expect(genAddMullTree(interpreterNum)(1, 9)).toBe(1);
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterStr`", () => {
    expect(genAddMullTree(interpreterStr)(37, 9)).toBe("((9*2)+(9+(5*2)))");
  });

  it("evaluates generated by `genAddMullTree` op sequence using `interpreterNumThunk`", () => {
    for (let n = 1; n <= 100; n++)
      expect(genAddMullTree(interpreterNumThunk)(n, 9)()).toBe(n);
  });

  it("stack safe versions", () => {
    const n = 2 ** 16;

    // Two following are stack safe because of an eager evaluation in interpreters
    expect(() => {
      expect(genAddOneTree(interpreterNum)(n)).toBe(n);
    }).not.toThrow();

    expect(() => {
      genAddOneTree(interpreterStr)(n);
    }).not.toThrow();

    // Not stack safe because a tree of thunks is too tall
    expect(() => {
      genAddOneTree(interpreterNumThunk)(n)();
    }).toThrow();

    // Two following a stack safe because of `Eval`-wrapping
    expect(() => {
      expect(genAddOneTree(interpreterNumEval)(n).value).toBe(n);
    }).not.toThrow();

    expect(() => {
      genAddOneTree(interpreterStrEval)(n).value;
    }).not.toThrow();
  });
});
